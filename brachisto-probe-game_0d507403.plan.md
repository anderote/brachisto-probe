---
name: brachisto-probe-game
overview: Plan for building a Flask + JavaScript + Three.js incremental game where players optimize von Neumann probe production to construct a Dyson sphere in minimum time, with user accounts, leaderboards, build sequence recording, and a Python-like scripting system for automation.
todos:
  - id: setup-project
    content: Set up project structure, Flask app skeleton, PostgreSQL database configuration, and basic routing
    status: completed
  - id: game-engine
    content: Implement core game engine with resource management, probe system, structure purchases, and research upgrades
    status: completed
  - id: database-models
    content: Create database models for User, GameSession, BuildSequence, and Score with migrations
    status: completed
  - id: api-endpoints
    content: Implement Flask API endpoints for authentication, game state management, and score tracking
    status: completed
  - id: threejs-scene
    content: Create Three.js scene with solar system visualization (star, planets, orbits, asteroid belt)
    status: completed
  - id: visualization-probes
    content: Implement probe rendering (dots) and Dyson sphere particle system with twinkling effect
    status: completed
  - id: ui-purchase-panel
    content: Build right-side purchase panel with structure list, costs, hotkeys, and purchase functionality
    status: completed
  - id: ui-research-panel
    content: Create top research panel with progress bars, intelligence allocation, and real-time updates
    status: completed
  - id: ui-resource-display
    content: Implement resource counters (energy, metal, intelligence, dexterity) with formatted units
    status: completed
  - id: scripting-system
    content: Build Python-like DSL parser, sandboxed executor, and scripting window UI with code editor
    status: completed
  - id: game-balance
    content: Tune growth formulas, structure costs, research efficiency to achieve 15-20 minute gameplay target
    status: pending
  - id: leaderboard
    content: Implement leaderboard display, user profiles, build sequence viewing, and score comparison
    status: pending
  - id: watch-mode
    content: Add watch mode functionality to replay build sequences with playback controls
    status: pending
  - id: polish-ux
    content: Add tooltips, notifications, achievements, statistics graphs, and responsive design
    status: pending
---

# Brachisto-Probe Game Implementation Plan

## Architecture Overview

The game follows a client-server architecture:

- **Backend**: Flask API for game state persistence, user authentication, leaderboards, and script execution
- **Frontend**: Three.js visualization with React/Vanilla JS for UI, real-time game simulation running at ~60 ticks/sec
- **Database**: PostgreSQL for users, sessions, scores, and build sequences

## Project Structure

```
brachisto-probe/
├── backend/
│   ├── app.py                 # Main Flask application
│   ├── models.py              # Database models (User, GameSession, Score, BuildSequence)
│   ├── auth.py                # Authentication utilities
│   ├── game_engine.py         # Core game simulation logic
│   ├── scripting.py           # Python-like DSL parser and executor
│   ├── api/
│   │   ├── __init__.py
│   │   ├── auth.py            # Auth endpoints
│   │   ├── game.py            # Game state endpoints
│   │   ├── scores.py          # Leaderboard endpoints
│   │   └── scripts.py         # Script execution endpoints
│   └── config.py              # Configuration (DB, secrets)
├── frontend/
│   ├── index.html
│   ├── static/
│   │   ├── css/
│   │   │   └── style.css
│   │   ├── js/
│   │   │   ├── main.js        # Entry point
│   │   │   ├── game/
│   │   │   │   ├── engine.js  # Game state and tick simulation
│   │   │   │   ├── resources.js # Resource management
│   │   │   │   └── upgrades.js  # Upgrades system
│   │   │   ├── visualization/
│   │   │   │   ├── scene.js   # Three.js scene setup
│   │   │   │   ├── solar_system.js # Planet/orbit rendering
│   │   │   │   └── probes.js  # Probe rendering
│   │   │   ├── ui/
│   │   │   │   ├── purchase_panel.js # Right-side structure panel
│   │   │   │   ├── research_panel.js # Top research monitors
│   │   │   │   ├── resource_display.js # Resource counters
│   │   │   │   ├── scripting_window.js # Scripting interface
│   │   │   │   └── leaderboard.js # Score display
│   │   │   └── api.js         # API communication
│   │   └── shaders/           # Custom Three.js shaders
│   └── templates/
│       └── index.html
├── migrations/                # Database migrations (Flask-Migrate)
├── requirements.txt
├── README.md
└── .env.example
```

## Core Game Systems

### 1. Resource Types

**Fundamental Resources (rate-based):**

- `energy` (watts): Generated by solar panels, consumed by construction/compute
- `metal` (kg/s): Harvested from planets/asteroids, consumed by construction

**Productive Resources:**

- `intelligence`: Research capability, improves efficiencies
- `dexterity`: Construction/harvest capability

### 2. Game Entities

**Von Neumann Probes:**

- Base stats: `dexterity_per_probe` (configurable, e.g., 1.0 dexterity/probe)
- Can be allocated to:
                                - **Harvest**: Collect metal from celestial bodies (consumes energy)
                                - **Construct**: Build structures/probes (consumes metal + energy)
                                - **Build Dyson Sphere**: Direct contribution to sphere (consumes metal + energy)

**Fixed Structures** (purchasable, right panel):

- **Lunar Mass Drivers**: +metal production, energy cost
- **Orbital Factories**: +probe production rate, +construction efficiency
- **Space Elevators**: +transport efficiency, reduces energy cost
- **Ground-based Factories**: +probe production, +metal processing
- Each structure has: cost (metal/energy), production bonuses, efficiency multipliers

**Research Upgrades** (continuous, top panel):

- **Propulsion Research**: Increases probe speed/efficiency
- **Robot Dexterity**: Increases dexterity per probe
- **Factory Edge Compute**: Increases factory efficiency
- **Energy Efficiency**: Reduces energy consumption
- **Slag Upcycling**: Improves slag-to-metal conversion
- Research progresses over time, costs intelligence allocation

### 3. Dyson Sphere Construction

**Mass Target**: Use scaled realistic value (~10^23 kg base, adjustable for balance)

- Construction rate depends on:
                                - Allocated dexterity
                                - Available metal (rate-limited by metal/s)
                                - Available energy (rate-limited by watts)
                                - Efficiency multipliers from research/structures

**Completion**: When `dyson_sphere_mass >= target_mass`

### 4. Game Metrics

**Primary Score**: Time to completion (seconds)

**Secondary Score**: Remaining metal in solar system (kg)

**Build Sequence**: Ordered list of all purchases/research allocations with timestamps

## Database Schema

```python
# models.py structure

User:
  - id (primary key)
  - username (unique)
  - email
  - password_hash
  - created_at

GameSession:
  - id (primary key)
  - user_id (foreign key)
  - started_at
  - completed_at (nullable)
  - final_time (seconds, nullable)
  - remaining_metal (kg, nullable)
  - game_config (JSON) # Difficulty settings, etc.

BuildSequence:
  - id (primary key)
  - session_id (foreign key)
  - action_type (enum: purchase, research, script_execution)
  - action_data (JSON)
  - timestamp (relative to session start)
  - tick_number

Score:
  - id (primary key)
  - user_id (foreign key)
  - session_id (foreign key)
  - completion_time (seconds)
  - remaining_metal (kg)
  - score_value (computed: f(time, metal))
  - created_at
```

## Game Engine Implementation

### Core Simulation Loop (`game_engine.py`)

```python
class GameEngine:
    def __init__(self):
        self.tick = 0
        self.resources = Resources(energy=0, metal=0, intelligence=0, dexterity=0)
        self.probes = 1  # Starting probe
        self.structures = {}
        self.research = {}
        self.dyson_sphere_mass = 0
        self.solar_system_metal = self.calculate_initial_metal()
    
    def tick(self):
        # 1. Update research progress
        # 2. Calculate production rates (energy, metal, probes)
        # 3. Apply consumption
        # 4. Update Dyson sphere construction
        # 5. Increment tick counter
```

**Resource Production Formulas:**

- Energy: `Σ(solar_panel_efficiency * structures[i].energy_output)`
- Metal: `probes_harvesting * dexterity_per_probe * harvest_efficiency * (1 + research_bonuses)`
- Probe Production: `base_rate * factory_multiplier * (1 + research_bonuses)`

**Time Handling**: Store `last_tick_time` and use `requestAnimationFrame` for smooth updates. Handle tab inactivity by calculating catch-up ticks when tab becomes active again.

## Backend API Endpoints

```
POST   /api/auth/register
POST   /api/auth/login
POST   /api/auth/logout
GET    /api/auth/me

POST   /api/game/start          # Create new session
POST   /api/game/action         # Purchase/research action
GET    /api/game/state/:id      # Get current game state
POST   /api/game/script         # Execute script command

GET    /api/scores/leaderboard  # Top scores
GET    /api/scores/user/:id     # User's scores
GET    /api/scores/build/:id    # Build sequence for session

POST   /api/watch/start         # Start watch mode with build sequence
GET    /api/watch/state         # Current watch state
```

## Frontend Implementation

### Three.js Visualization

**Scene Setup** (`visualization/scene.js`):

- Camera: PerspectiveCamera, wide FOV for solar system view
- Lighting: AmbientLight + PointLight (Sun)
- Particle system for Dyson sphere twinkling effect
- Orbit controls for optional camera movement

**Solar System** (`visualization/solar_system.js`):

- Central star (bright PointLight + sphere)
- Planets as small colored sprites (Earth=blue, others by type)
- Asteroid belt as particle field
- Orbital mechanics: Simple circular orbits, not to scale
- Smooth orbital animation

**Probes** (`visualization/probes.js`):

- Grey dots (Points material)
- Trail effects for active probes
- Visual feedback for allocation (harvest/construct/sphere)

**Dyson Sphere** (`visualization/dyson_sphere.js`):

- Particle system around star
- Density increases with `dyson_sphere_mass / target_mass`
- Twinkling effect (opacity variation, color variation)

### UI Components

**Purchase Panel** (right side):

- Scrollable list of structures
- Each item shows: name, cost (metal + energy), current count, production bonus
- Hotkey buttons (Q, W, E, R, etc.)
- Visual feedback on affordability

**Research Panel** (top):

- Horizontal bar for each research type
- Progress percentage, current level
- Intelligence allocation slider/input
- Real-time updates

**Scripting Window**:

- Code editor (CodeMirror or Monaco)
- Python-like syntax highlighting
- Example commands:
  ```
  if metal > 1000:
      purchase("orbital_factory")
  if tick % 60 == 0:  # Every second
      allocate_research("propulsion", 0.1)
  ```


## Scripting System

### Python-like DSL Parser (`scripting.py`)

**Supported Features:**

- Variables: `metal`, `energy`, `tick`, `probes`, etc.
- Arithmetic: `+`, `-`, `*`, `/`, `**`
- Comparisons: `>`, `<`, `>=`, `<=`, `==`, `!=`
- Conditionals: `if`, `elif`, `else`
- Loops: `for`, `while` (with safety limits)
- Functions: `purchase(name)`, `allocate_research(name, amount)`, `log(message)`
- Time expressions: `tick`, `seconds()`, `minutes()`

**Safety:**

- Sandboxed execution (no file/network access)
- Rate limiting (max script executions per tick)
- Timeout protection
- Syntax validation before execution

## Game Balance Considerations

### Growth Rate Targets

Design formulas to achieve:

- **10 minutes**: Requires optimal play, excellent scripting, good RNG understanding
- **15-20 minutes**: Normal play, some optimization
- **30 minutes**: Casual play, suboptimal choices

**Key Balance Levers:**

1. **Starting resources**: Initial probe dexterity, starting metal/energy
2. **Structure costs**: Exponential scaling to prevent trivial solutions
3. **Research efficiency**: Diminishing returns on high-level research
4. **Metal availability**: Total solar system metal (scaled from realistic ~10^23 kg)
5. **Energy generation**: Solar panel efficiency, scaling with structures

**Differential Equation Approach:**

Model growth as: `d(probes)/dt = f(probes, structures, research, resources)`

Example: `d(probes)/dt = probes * base_rate * (1 + factory_multiplier) * (1 + research_bonus) - construction_cost_rate`

### Example Balance Formula

```python
# Probe production rate
probe_rate = (
    base_probe_rate * probes * 
    (1 + sum(structure.factory_bonus for structure in structures)) *
    (1 + research.factor('factory_efficiency'))
) / (1 + construction_efficiency_penalty)

# Energy production
energy_rate = (
    sum(structure.energy_output for structure in structures) *
    (1 + research.factor('solar_efficiency'))
)

# Metal harvest
metal_rate = (
    probes_harvesting * dexterity_per_probe *
    (1 + research.factor('harvest_efficiency')) *
    base_harvest_rate
) * (1 - metal_depletion_factor)  # Diminishing as metal depletes
```

## Additional Gameplay Features

1. **Achievements**: Unlock badges for milestones (first probe, 1000 probes, etc.)
2. **Difficulty Modes**: Adjust metal availability, research costs
3. **Build Templates**: Save/load common build sequences
4. **Replay System**: Watch mode with playback controls (pause, speed up)
5. **Statistics**: Graphs showing resource growth over time
6. **Notifications**: Alert when structures become affordable
7. **Tooltips**: Helpful explanations for all mechanics

## Technical Considerations

1. **State Synchronization**: Client calculates state locally, syncs to server periodically (every 10 seconds) and on important actions
2. **Performance**: Use object pooling for Three.js objects, limit particle counts
3. **Mobile Support**: Responsive UI, touch-friendly controls (optional)
4. **Persistence**: Save game state on server, allow resume
5. **Error Handling**: Graceful degradation if Three.js unavailable, fallback to 2D canvas

## Implementation Phases

1. **Phase 1**: Core game engine, basic UI, local play
2. **Phase 2**: Three.js visualization, solar system rendering
3. **Phase 3**: Backend API, authentication, database
4. **Phase 4**: Scripting system, leaderboards
5. **Phase 5**: Polish, balance tuning, watch mode